/**
 * @file MinimumSpanningTreePrimFibonacci.cpp
 * @date 19/09/2019
 * @author Ritik Jain
 * @brief Minimum Spanning Tree Generator (Prim's / Fibonacci) Definitions File
 */

#include "MinimumSpanningTreePrimFibonacci.h"

using namespace asn5;

MSTGen::MSTGen()
{
    parent = nullptr;
    E = nullptr;
    V = nullptr;
    NE = NV = 0;
}

void MSTGen::pushTuple(int &N, tuple<int,int,int>* &T, tuple<int,int,int> &E)
{
if(!N)
{
    T = new tuple<int,int,int>{E};
    N = 1;
}
else
{
    int i;

    tuple <int,int,int> *_T = new tuple<int,int,int>[N+1];
    for(i=0; i<N; i++)
    _T[i] = T[i];
    _T[N] = E;
    N++;
    T = _T;
    _T = nullptr; 
}
}

void MSTGen::popTuple(int &N, tuple<int,int,int>* &T)
{
    if(!N)
    return;

    N--;
}

bool MSTGen::load_csv(const char *file_name)
{
    FILE *fp = fopen(file_name,"read");
    if(!fp)
    return false;
    
    char *j = nullptr, *v1 = nullptr, *v2 = nullptr;
    int _v1,_v2,w;
    tuple<int,int,int> e;

    fgets(BUF,BUFSZ,fp);

    while(!feof(fp))
    {
    fgets(BUF, BUFSZ, fp);

    if(!isValid())
    continue;

    v1= strtok(BUF,",");
    v2 = strtok(NULL, ",");
    j= strtok(NULL,"\0");
    trim(v1);
    trim(v2);
    trim(j);
    w = atoi(j);

    _v1 = addVertex(v1);
    _v2 = addVertex(v2);

    e = make_tuple(_v1,_v2,w);

    pushTuple(NE,E,e);

    }

    fclose(fp);
    return true;
}

void MSTGen::trim(char* &s)
{
    if(!s)return;
    int j=0;
    while(s[j++]==' ')
    s++;
    while(s[j]!='\0' && s[j]==' ')
    j++;
    s[j] = '\0';
}

bool MSTGen::isValid()
{
return (strlen(BUF)-1);
}

int MSTGen::addVertex(char* _v)
{
    if(!_v)
    return -1;

    char *v = new char[strlen(_v)];
    strcpy(v,_v);

    int j;

    for(j = 0; j < NV; j++)
    if(!strcmp(V[j],v))
    return j;

    if(NV)
    {
        char **_V = new char* [NV+1];
        for(j=0; j<NV; j++)
        _V[j] = V[j];
        V = _V;
        V[NV] = v;
    }
    else
    {
        V = new char*;
        *V =  v;
    }
    
    NV++;

    return NV-1;
}

void MSTGen::cut(int v)
{
    int i;
    for(i=0; i<NE; i++)
    {
        if(get<0>(E[i])==v)
        {
            Data data(get<1>(E[i]), get<2>(E[i]));
            if(heap.decreaseKey(get<1>(E[i]), data))
                parent[get<1>(E[i])] = v;
        }
        else if(get<1>(E[i])==v)
        {
            Data data(get<0>(E[i]),get<2>(E[i]));
            if(heap.decreaseKey(get<0>(E[i]), data))
                parent[get<0>(E[i])] = v;
        }
        
    }
}

void MSTGen::genMST()
{
    parent = new int[NV];

    int i;
    for(i=0; i < NV; i++)
    {
        if(!i)
            heap.insert(Data(i,0));
        else
            heap.insert(Data(i,INT32_MAX));

        parent[i] = -1;   
    }
    
    Data u = heap.extractMinimum();
    cut(u.v);

    for(i=1; i < NV; i++)
    {
        Data v = heap.extractMinimum();
        cut(v.v);
        u = v;
    }
}

bool MSTGen::save_dot(const char *file_name)
{
    fstream out(file_name,ios::out);

    if(!out)
    return false;

    out <<  "/**\n* Copyright (C) 2019 Ritik Jain\n* Graph File generated by Minimum Spanning Tree Generator ver 1.0.0\n* Licensed under GNU Public License\n*/\n\n";

    out << "graph output\n{\n";

    out << "//Vertices\n";

    int j;
    for(j=0; j<NV; j++)
    out << V[j] <<";\n";

    out << "\n//Edges\n";

    for(j=0; j<NE; j++)
    {
        int v1 = get<0>(E[j]);
        int v2 = get<1>(E[j]);

        if(parent[v1]==v2 || parent[v2]==v1)
            out << V[v1] << "--" << V[v2] << " [label=\"" << get<2>(E[j]) << "\"];" << endl;
    }

    out << "}\n//End of graph\n";

    out.close();

    return true;
}

int MSTGen::weightGraph()
{
    int w=0;
    int j;
    for(j=0; j<NE; j++)
        w+=get<2>(E[j]);
    
    return w;
}

int MSTGen::weightMST()
{
    int w=0;
    int j;
    for(j=0; j<NE; j++)
    {
        int v1 = get<0>(E[j]);
        int v2 = get<1>(E[j]);

        if(parent[v1]==v2 || parent[v2]==v1)
            w += get<2>(E[j]);
    }

    return w;
}

void MSTGen::displayMST()
{
    cout <<endl;
    cout <<"Vertices [Total = "<<NV<<"] :"<<endl;
    int j,_NE=0;
    for(j=0; j<NV; j++)
    {
    cout <<V[j]<<endl;
    if(parent[j]!=-1)
    _NE++;
    }
    cout<<endl;
    cout<<"Edges [Total = "<<_NE<<"] :"<<endl;
    cout<<"Vertex 1\tVertex 2\tWeight"<<endl;
    for(j=0;j<NE;j++)
    {
        int v1 = get<0>(E[j]);
        int v2 = get<1>(E[j]);

        if(parent[v1]==v2 || parent[v2]==v1)
        cout<<V[get<0>(E[j])]<<"\t\t"<<V[get<1>(E[j])]<<"\t\t"<<get<2>(E[j])<<endl;
    }
    cout<<endl;
}

void MSTGen::displayGraph()
{
    cout <<endl;
    cout <<"Vertices [Total = "<<NV<<"] :"<<endl;
    int j;
    for(j=0; j<NV; j++)
    cout <<V[j]<<endl;
    cout<<endl;
    cout<<"Edges [Total = "<<NE<<"] :"<<endl;
    cout<<"Vertex 1\tVertex 2\tWeight"<<endl;
    for(j=0;j<NE;j++)
    cout<<V[get<0>(E[j])]<<"\t\t"<<V[get<1>(E[j])]<<"\t\t"<<get<2>(E[j])<<endl;
    cout<<endl;
}