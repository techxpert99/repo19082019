/**
 * @file MinimumSpanningTreeKruskalUnionFindGenerator.cpp
 * @date 18/09/2019
 * @author Ritik Jain
 * @brief Minimum Spanning Tree Generation Definitions File
 */

#include "MinimumSpanningTreeKruskalUnionFindGenerator.h"

using namespace asn5;

MSTGen::MSTGen()
{
    E = nullptr;
    V = nullptr;
    NE = NV = 0;
}

MSTGen::~MSTGen()
{
    delete [] E;

    delete [] V;
}

void MSTGen::weightedSort()
{
    if(!NE)
    return;

    tuple <int,int,int> min;

    int i,j,k;

    for(i=0; i < NE; i++)
    {
        min = E[i];
        k = i;

        for(j=i+1; j < NE; j++)
        {
            if(get<2>(E[j])<get<2>(min))
            {
                min = E[j];
                k = j;
            }
        }

        if(k!=i)
        {
            E[k]=E[i];
            E[i] = min;
        }
    }
}


void MSTGen::pushTuple(int &N, tuple<int,int,int>* &T, tuple<int,int,int> &E)
{
if(!N)
{
    T = new tuple<int,int,int>{E};
    N = 1;
}
else
{
    int i;

    tuple <int,int,int> *_T = new tuple<int,int,int>[N+1];
    for(i=0; i<N; i++)
    _T[i] = T[i];
    _T[N] = E;
    N++;
    T = _T;
    _T = nullptr; 
}
}

void MSTGen::popTuple(int &N, tuple<int,int,int>* &T)
{
    if(!N)
    return;

    N--;
}

bool MSTGen::union_find(int v1, int v2, int *parent)
{
    int s1 = find(v1, parent);
    int s2 = find(v2, parent);

    if(s1==s2)
    return false;

    parent[s1] = s2;

    return true;
}

int MSTGen::find(int v, int *parent)
{
    if(parent[v]==-1)
    return v;
    
    return find(parent[v],parent);
}

bool MSTGen::hasCycle(int NE, tuple<int,int,int>* &E)
{
    int *parent = new int[NV];
    int i,v1,v2;

    for(i=0; i<NV; i++)
    parent[i] = -1;

    for(i=0; i<NE; i++)
    {
        v1 = get<0>(E[i]);
        v2 = get<1>(E[i]);

        if(!union_find(v1,v2,parent))
        {
            delete [] parent;
            return true;
        }        
    }

    return false;

}

void MSTGen::genMST()
{
    weightedSort();

    tuple <int,int,int> e;

    int i,_NE=0;

    tuple <int,int,int> *_E = new tuple<int,int,int>;

    for(i=0; i<NE; i++)
    {
        e = E[i];
        pushTuple(_NE,_E,e);
        if(hasCycle(_NE, _E))
        popTuple(_NE,_E);
    }

    E = _E;
    NE = _NE;
}

void MSTGen::trim(char* &s)
{
    if(!s)return;
    int j=0;
    while(s[j++]==' ')
    s++;
    while(s[j]!='\0' && s[j]==' ')
    j++;
    s[j] = '\0';
}

bool MSTGen::isValid()
{
return (strlen(BUF)-1);
}

bool MSTGen::load_csv(const char *file_name)
{
    FILE *fp = fopen(file_name,"read");
    if(!fp)
    return false;
    
    char *j = nullptr, *v1 = nullptr, *v2 = nullptr;
    int _v1,_v2,w;
    tuple<int,int,int> e;

    fgets(BUF,BUFSZ,fp);

    while(!feof(fp))
    {
    fgets(BUF, BUFSZ, fp);

    if(!isValid())
    continue;

    v1= strtok(BUF,",");
    v2 = strtok(NULL, ",");
    j= strtok(NULL,"\0");
    trim(v1);
    trim(v2);
    trim(j);
    w = atoi(j);

    _v1 = addVertex(v1);
    _v2 = addVertex(v2);

    e = make_tuple(_v1,_v2,w);

    pushTuple(NE,E,e);

    }

    fclose(fp);
    return true;
}

int MSTGen::addVertex(char* _v)
{
    if(!_v)
    return -1;

    char *v = new char[strlen(_v)];
    strcpy(v,_v);

    int j;

    for(j = 0; j < NV; j++)
    if(!strcmp(V[j],v))
    return j;

    if(NV)
    {
        char **_V = new char* [NV+1];
        for(j=0; j<NV; j++)
        _V[j] = V[j];
        V = _V;
        V[NV] = v;
    }
    else
    {
        V = new char*;
        *V =  v;
    }
    
    NV++;

    return NV-1;
}

void MSTGen::display()
{
    cout <<endl;
    cout <<"Vertices [Total = "<<NV<<"] :"<<endl;
    int j;
    for(j=0; j<NV; j++)
    cout <<V[j]<<endl;
    cout<<endl;
    cout<<"Edges [Total = "<<NE<<"] :"<<endl;
    cout<<"Vertex 1\tVertex 2\tWeight"<<endl;
    for(j=0;j<NE;j++)
    cout<<V[get<0>(E[j])]<<"\t\t"<<V[get<1>(E[j])]<<"\t\t"<<get<2>(E[j])<<endl;
    cout<<endl;
}

int MSTGen::weight()
{
    int w=0;
    for(int i = 0; i < NE; i++)
    w += get<2>(E[i]);

    return w;
}

bool MSTGen::save_dot(const char *file_name)
{
    fstream out(file_name,ios::out);

    if(!out)
    return false;

    out <<  "/**\n* Copyright (C) 2019 Ritik Jain\n* Graph File generated by Minimum Spanning Tree Generator ver 1.0.0\n* Licensed under GNU Public License\n*/\n\n";

    out << "graph output\n{\n";

    out << "//Vertices\n";

    int j;
    for(j=0; j<NV; j++)
    out << V[j] <<";\n";

    out << "\n//Edges\n";

    for(j=0; j<NE; j++)
    out << V[get<0>(E[j])] << "--" << V[get<1>(E[j])] << " [label=\""<<get<2>(E[j])<<"\"];\n";

    out << "}\n//End of graph\n";

    out.close();

    return true;
}
